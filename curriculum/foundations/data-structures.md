[← Back to Curriculum](../README.md)

---

# Data Structures & Algorithms

- **Complexity Analysis & Big-O Notation**

  - Time complexity: best, average, worst case analysis
  - Space complexity: auxiliary vs total space, in-place algorithms
  - Amortized analysis: aggregate, accounting, potential methods
  - Master theorem for divide-and-conquer recurrences
  - Big-O, Big-Θ, Big-Ω notations, growth rates comparison
  - Practical performance vs theoretical complexity

- **Fundamental Data Structures**

  - Arrays: static vs dynamic, resizing strategies, memory layout
  - Linked lists: singly, doubly, circular, skip lists
  - Stacks: LIFO operations, call stack, expression evaluation
  - Queues: FIFO, circular queues, priority queues, deques
  - Hash tables: collision resolution, load factor, rehashing
  - Trees: binary trees, BST, balanced trees, heaps, tries

- **Graph Algorithms & Network Analysis**

  - Graph representations: adjacency matrix, adjacency list
  - DFS: recursive/iterative, topological sort, components
  - BFS: shortest path, level-order traversal
  - Dijkstra's algorithm: single-source shortest path
  - A\* search: heuristic search, admissible heuristics
  - Network flow: Ford-Fulkerson, maximum matching

- **Dynamic Programming & Optimization**

  - DP principles: optimal substructure, overlapping subproblems
  - Memoization vs tabulation: top-down vs bottom-up
  - Classic problems: knapsack, LCS, LIS, edit distance
  - State space optimization: rolling arrays, space-efficient DP
  - Advanced DP: digit DP, bitmask DP, probability DP

- **Probabilistic & Approximate Structures**

  - Bloom filters: false positives, optimal hash functions
  - Count-Min sketch: frequency estimation, heavy hitters
  - HyperLogLog: cardinality estimation, distributed counting
  - Skip lists: probabilistic balanced structures
  - Consistent hashing: distributed systems, load balancing

- **Caching Strategies & Implementation**
  - Cache replacement policies: LRU, LFU, FIFO, random
  - LRU implementation: doubly linked list + hash map
  - Cache-aware algorithms: blocking, tiling, optimization
  - Memory hierarchy: CPU cache, main memory, disk storage
  - Spatial vs temporal locality, cache-friendly structures
- Big-O, amortized analysis
- Arrays, lists, heaps, tries, graphs
- DFS/BFS, Dijkstra, A\*, topological sort
- Dynamic-programming templates, memoization
- Probabilistic DS (Bloom, HyperLogLog)
- Caching strategies (LRU/LFU)
