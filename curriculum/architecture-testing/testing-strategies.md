[‚Üê Back to Curriculum](../README.md)

---

# Testing & Quality Engineering

- **Testing Pyramid & Strategy**

  - Unit testing: isolation, mocking, test doubles, coverage, fast feedback
  - Integration testing: component interaction, database integration, external services
  - End-to-end testing: user workflows, browser automation, mobile testing, flaky tests
  - Contract testing: API contracts, consumer-driven contracts, schema validation
  - Performance testing: load testing, stress testing, endurance testing, scalability
  - Security testing: vulnerability scanning, penetration testing, compliance validation
  - Test strategy: risk-based testing, test planning, resource allocation, timeline

- **Advanced Testing Techniques**

  - Property-based testing: Hypothesis, QuickCheck, invariant testing, edge case discovery
  - Mutation testing: code quality assessment, test effectiveness, surviving mutants
  - Fuzzing: input generation, crash detection, security vulnerabilities, coverage-guided
  - Chaos testing: failure injection, resilience testing, production testing, game days
  - A/B testing: statistical significance, experiment design, metrics collection, analysis
  - Canary testing: gradual rollout, risk mitigation, automated rollback, monitoring
  - Shadow testing: production traffic, risk-free validation, performance comparison

- **Test Automation & CI/CD**

  - Test automation frameworks: Selenium, Cypress, Playwright, mobile automation
  - CI/CD integration: test gates, parallel execution, test reporting, artifact management
  - Test data management: test data generation, data masking, environment provisioning
  - Test environment management: containerization, infrastructure as code, environment parity
  - Flaky test management: detection, quarantine, root cause analysis, stabilization
  - Test parallelization: test splitting, resource allocation, result aggregation
  - Test reporting: dashboards, trend analysis, failure analysis, quality metrics

- **Quality Metrics & Monitoring**

  - Code coverage: statement, branch, condition, path coverage, coverage goals
  - Test metrics: pass rate, execution time, flakiness, test debt, maintenance cost
  - Quality gates: code review, static analysis, security scanning, performance testing
  - Defect tracking: bug lifecycle, severity classification, root cause analysis, trends
  - Quality dashboards: real-time metrics, historical trends, team performance, alerts
  - SLA monitoring: uptime, performance, error rates, customer satisfaction
  - Technical debt: identification, measurement, prioritization, remediation planning

- **Specialized Testing Domains**

  - Mobile testing: device compatibility, network conditions, battery usage, app store validation
  - API testing: contract validation, performance testing, security testing, documentation
  - Database testing: data integrity, performance, migration testing, backup/restore
  - Security testing: OWASP top 10, penetration testing, vulnerability assessment, compliance
  - Accessibility testing: WCAG compliance, screen reader testing, keyboard navigation
  - Internationalization testing: localization, character encoding, cultural adaptation
  - Performance testing: load testing, stress testing, volume testing, scalability testing

- **Test Organization & Culture**

  - Test-driven development: red-green-refactor, design benefits, discipline, tooling
  - Behavior-driven development: Gherkin, stakeholder collaboration, living documentation
  - Shift-left testing: early testing, developer testing, fast feedback, cost reduction
  - Quality engineering: quality advocacy, process improvement, tooling, training
  - Testing communities: knowledge sharing, best practices, tool evaluation, standards
  - Continuous improvement: retrospectives, metrics analysis, process optimization
  - Testing skills: technical skills, domain knowledge, analytical thinking, communication

- **Testing Tools & Ecosystem**
  - Test frameworks: JUnit, pytest, Jest, RSpec, language-specific frameworks
  - Mock frameworks: Mockito, unittest.mock, Sinon, test doubles, verification
  - Test data tools: Faker, Factory Boy, data generation, anonymization, masking
  - Visual testing: screenshot comparison, visual regression, cross-browser testing
  - Load testing tools: JMeter, k6, Gatling, cloud-based solutions, distributed testing
  - Security testing tools: OWASP ZAP, Burp Suite, static analysis, dependency scanning
  - Test management: test case management, test execution tracking, reporting, integration
